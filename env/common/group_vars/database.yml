postgresql_databases:
  - name: "{{galaxy_database}}"
#    login_host: "{{galaxy_host}}"
#    login_password: "{{galaxy_db_passwd}}"
#     login_user: "{{galaxy_db_user}}"
#    login_unix_socket: # defaults to 1st of postgresql_unix_socket_directories
    owner: "{{galaxy_db_user}}"

postgresql_users:
  - name: "{{galaxy_db_user}}"
    password: "{{galaxy_db_passwd}}"
  - name: telegraf
    password: null

# Host based authentication (hba) entries to be added to the pg_hba.conf. This
# variable's defaults reflect the defaults that come with a fresh installation.
postgresql_hba_entries:
  - {type: local, database: all, user: postgres, auth_method: peer}
  - {type: host, database: all, user: all, address: '127.0.0.1/32', auth_method: md5}
  - {type: host, database: all, user: all, address: '::1/128', auth_method: md5}
# Makes it possible for the galaxy-db use to connect both from localhost and the galaxy-host (ip based
  - {type: local, database: "{{galaxy_database}}", user: "{{galaxy_db_user}}", auth_method: md5}
  - {type: host, database: "{{galaxy_database}}", user: "{{galaxy_db_user}}", address: "{{ galaxy_ip }}/32", auth_method: md5}
  - {type: host, database: "{{galaxy_database}}", user: telegraf, address: "{{ galaxy_ip }}/32", auth_method: trust}
# This is needed to ensure that the database exists and comes from sqlalchemy not the galaxy code!
  - {type: host, database: "postgres", user: "{{galaxy_db_user}}", address: "{{ galaxy_ip }}/32", auth_method: md5}
# If encryptions between galaxy and post is needed
#  - {type: hostssl, database: "{{galaxy_database}}", user: "{{galaxy_db_user}}", address: "{{galaxy_ip}}/0", auth_method: md5}

# Grant telegraf privileges to
# SELECT values from the Galaxy database
postgresql_objects_privileges:
  - database: "{{galaxy_database}}"
    roles: telegraf
    privs: SELECT
    objs: ALL_IN_SCHEMA
postgresql_privs:
    db: "{{ galaxy_database }}"
    privs: SELECT, USAGE
    roles: telegraf
    objs: ALL_IN_SCHEMA
    state: present
    grant_option: yes

postgresql_global_config_options:
  - option: listen_addresses
    value: '*'
#  - option: ssl
#    value: "on"
#  - option: ssl_cert_file
#    value: "{{ssl_cert}}"
#  - option: ssl_key_file
#    value: "{{ssl_key}}"

# Certbot
certbot_auto_renew_hour: "{{ 23 |random(seed=inventory_hostname)  }}"
certbot_auto_renew_minute: "{{ 59 |random(seed=inventory_hostname)  }}"
certbot_auth_method: --webroot
certbot_install_method: virtualenv
certbot_auto_renew: yes
certbot_auto_renew_user: root
certbot_environment: production
#certbot_environment: staging
certbot_well_known_root: /srv/nginx/_well-known_root
certbot_share_key_users:
  - nginx
certbot_post_renewal: |
    systemctl restart nginx || true
certbot_domains:
 - "{{ inventory_hostname }}"
certbot_agree_tos: --agree-tos

# NGINX
nginx_selinux_allow_local_connections: true
nginx_servers:
  - redirect-ssl
nginx_enable_default_server: false
nginx_ssl_servers:
  - rabbitmq
nginx_conf_http:
  client_max_body_size: 1g
nginx_ssl_role: usegalaxy_eu.certbot
nginx_conf_ssl_certificate: /etc/ssl/certs/fullchain.pem
nginx_conf_ssl_certificate_key: /etc/ssl/user/privkey-nginx.pem
